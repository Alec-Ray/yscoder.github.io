{"title":"html5调用手机相机并压缩、上传","slug":"webapp-input-use-camera","date":"2015-09-16T08:21:28.000Z","updated":"2016-08-15T13:28:56.417Z","comments":true,"path":"api/articles/webapp-input-use-camera.json","excerpt":"<p>近日刚做的一个功能，要在app里使用内嵌页面进行图像的上传。<br>从功能上看，原生的实现应该是最好的。毕竟页面上所有的东西都隔着一个浏览器，所有的实现都要依赖浏览器提供的接口，不同的浏览器对接口的实现又有差异……到最后又会陷入兼容性的大坑!<br>吐槽归吐槽，但是折腾的劲头不能丢！</p>","content":"<p>近日刚做的一个功能，要在app里使用内嵌页面进行图像的上传。<br>从功能上看，原生的实现应该是最好的。毕竟页面上所有的东西都隔着一个浏览器，所有的实现都要依赖浏览器提供的接口，不同的浏览器对接口的实现又有差异……到最后又会陷入兼容性的大坑!<br>吐槽归吐槽，但是折腾的劲头不能丢！</p>\n<a id=\"more\"></a>\n<!-- toc -->\n<h2 id=\"使用input-file-camera-属性调用相机\"><a href=\"#使用input-file-camera-属性调用相机\" class=\"headerlink\" title=\"使用input file[camera]属性调用相机\"></a>使用input file[camera]属性调用相机</h2><p>简直<strong>So easy！</strong></p>\n<pre><code>&lt;input type=&quot;file&quot; accept=&quot;image/*;&quot; capture=&quot;camera&quot; &gt;\n</code></pre><p>只需要这么一条简单的代码，在手机浏览器点击就可以打开相机了。</p>\n<p><code>capture</code>是什么？其实就是对打开方式的设置。</p>\n<pre><code>&lt;!-- capture=camcorder，调用手机摄像功能 --&gt;\n&lt;input type=&quot;file&quot; accept=&quot;video/*&quot; capture=&quot;camcorder&quot; &gt; \n&lt;!-- capture=microphone，调用手机录音功能 --&gt;\n&lt;input type=&quot;file&quot; accept=&quot;audio/*&quot; capture=&quot;microphone&quot; &gt;\n</code></pre><p>魅族MX5测试结果：</p>\n<ul>\n<li>谷歌浏览器可以打开相机和摄像功能，其他方式均为相机、图库、文件管理器等混合选择项。</li>\n<li>自带浏览器打开均为文件管理器。</li>\n</ul>\n<p>由此说明此属性兼容性还是个问题。不过这并不能阻止我继续折腾下去！</p>\n<h2 id=\"图片压缩\"><a href=\"#图片压缩\" class=\"headerlink\" title=\"图片压缩\"></a>图片压缩</h2><p>在如今这个手机普遍千万像素的时代，一张照片动辄5M的大小。作为一个良心的开发者，我们是要为用户的流量负责的。<br>该怎么做？我也不知道。大家都在用<code>canvas</code>实现，我也就用了。</p>\n<pre><code>document.getElementById(&apos;file&apos;).addEventListener(&apos;change&apos;, function() {\n\n    var reader = new FileReader();\n\n    reader.onload = function (e) {\n        compress(this.result);\n    };\n\n    reader.readAsDataURL(this.files[0]);\n\n}, false);\n</code></pre><p>不管文件域是用何种方式打开的，都可以在 <code>change</code> 事件中获取到选择的文件或拍摄的照片。</p>\n<p>创建一个<code>FileReader</code>对象，我们需要调用<code>readAsDataURL</code>把文件转换为<code>base64</code>图像编码，如<code>data:image/jpeg;base64……</code>这种格式。<br><code>onload</code>是一个异步回调，当文件读取完执行该方法内代码。<code>this.result</code>记录读取结果，如果读取失败，该值为<code>null</code>。在这里进行图片压缩的具体操作。</p>\n<pre><code>var compress = function (res) {\n    var img = new Image(),\n        maxH = 160;\n\n    img.onload = function () {\n        var cvs = document.createElement(&apos;canvas&apos;),\n            ctx = cvs.getContext(&apos;2d&apos;);\n\n        if(img.height &gt; maxH) {\n            img.width *= maxH / img.height;\n            img.height = maxH;\n        }\n\n        cvs.width = img.width;\n        cvs.height = img.height;\n\n        ctx.clearRect(0, 0, cvs.width, cvs.height);\n        ctx.drawImage(img, 0, 0, img.width, img.height);\n\n        var dataUrl = cvs.toDataURL(&apos;image/jpeg&apos;, 0.6);\n\n        // 上传略\n    }\n\n    img.src = res;\n}\n</code></pre><p>创建一个<code>Image</code>对象，给<code>src</code>属性赋值为读取结果，同样在<code>onload</code>异步回调中编写处理图片的代码。<br>这里就要开始使用<code>canvas</code>进行图片压缩了。</p>\n<p>首先是尺寸按比例缩放，然后把图片绘到画布上，最后调用<code>toDataURL</code>方法压缩图像质量。</p>\n<pre><code>context.toDataURL(&apos;MIME类型&apos;, 图像质量0-1);  // 该方法返回base64图像编码\n</code></pre><p>代码里省略了一些校监操作，如文件类型约束和文件大小判断（小于一定值可以不压缩）。<br>最后就是把数据发送到后端的操作，这里就不说了。</p>\n<h2 id=\"Html5调用摄像头\"><a href=\"#Html5调用摄像头\" class=\"headerlink\" title=\"Html5调用摄像头\"></a>Html5调用摄像头</h2><p>通过以上的代码已经可以实现调用手机相机拍照、压缩、上传这一整套流程了。<br>不过在折腾的过程中也发现了一种调用摄像头的方法。注意，是<code>摄像头</code>！使用input调用的是相机。其中的差别就是摄像头是只捕获画面，相机还包括原生的一些拍照、设置等控件。</p>\n<p>通过对摄像头的调用可以做很多有趣的事，比如拍照美化、滤镜等。可以说实现一个第三方相机是没问题的。<br>之前下载过一款安卓相机APP，不到100K的大小，可以实现拍照的一些风格化，也许就是Html5实现的呢。</p>\n<p>需要用到的是 <strong>getUserMedia API</strong>，具体的实现这里就不贴了。</p>\n","categories":[],"tags":[{"name":"html5","path":"api/tags/html5.json"},{"name":"webapp","path":"api/tags/webapp.json"},{"name":"file","path":"api/tags/file.json"}]}